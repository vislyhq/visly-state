(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{60:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(2),o=n(6),r=(n(0),n(72)),i={title:"Organizing code",sidebar_label:"Organizing code"},s={unversionedId:"organisation",id:"organisation",isDocsHomePage:!1,title:"Organizing code",description:"Visly State doesn't care how you organize your state, selectors, and mutations; however, we have discovered some patterns while building Visly which may be helpful to you in adopting Visly State.",source:"@site/docs/organisation.md",slug:"/organisation",permalink:"/docs/organisation",editUrl:"https://github.com/vislyhq/visly-state/edit/master/website/docs/organisation.md",version:"current",sidebar_label:"Organizing code",sidebar:"docs",previous:{title:"Syncing state",permalink:"/docs/syncing"}},c=[{value:"Combining local and remote state",id:"combining-local-and-remote-state",children:[]},{value:"Namespacing selectors and mutations",id:"namespacing-selectors-and-mutations",children:[]},{value:"Using smaller states for independant features",id:"using-smaller-states-for-independant-features",children:[]},{value:"Seperating shared code",id:"seperating-shared-code",children:[]}],l={rightToc:c};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Visly State doesn't care how you organize your state, selectors, and mutations; however, we have discovered some patterns while building Visly which may be helpful to you in adopting Visly State."),Object(r.b)("h2",{id:"combining-local-and-remote-state"},"Combining local and remote state"),Object(r.b)("p",null,"Typically, your local and remote state will depend on each another. For example, your data models will be remote state synced to the server, but you'll also have local state such as the ID of the item currently selected, which you don't want to sync to the server but which at the same time is dependant on what items exist in the data model. For this, we rely on ",Object(r.b)("inlineCode",{parentName:"p"},"combinedState")," to combine the remote and local states and write mutations and selectors which operate on this combined store."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"import { syncedState } from '@visly/state'\n\ninterface RemoteState {\n    items: Item[]\n}\n\ninterface LocalState {\n    selectedItemId: string | null\n}\n\ntype AppState = {\n    remote: RemoteState\n    local: LocalState\n}\n\nconst remoteState = syncedState<RemoteState>('remote', { items: [] })\nconst localState = state<LocalState>({ selectedItemId: null })\n\nexport const appState = combinedState<AppState>({\n    remote: remoteState,\n    local: localState,\n})\n\nexport const mutations = {\n    addItem: (state: AppState, item: Item) => {\n        state.remote.items.push(item)\n        state.local.selectedItemId = item.id\n    }\n}\n\nexport const selectors = {\n    selectedItem: (state: AppState) => {\n        return state.remote.items.find(item => {\n            return item.id === state.local.selectedItemId\n        })\n    }\n}\n")),Object(r.b)("h2",{id:"namespacing-selectors-and-mutations"},"Namespacing selectors and mutations"),Object(r.b)("p",null,"As you may have noticed throughout the examples, we tend to place mutations and selectors within exported objects called ",Object(r.b)("inlineCode",{parentName:"p"},"mutations")," and ",Object(r.b)("inlineCode",{parentName:"p"},"selectors"),". We typically export these objects from the module which defines the state. This makes it very obvious to the other developers which operations exist on the state."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"import { state } from '@visly/state'\n\nexport const appState = state({ ... })\nexport const mutations = { ... }\nexport const selectors = { ... }\n")),Object(r.b)("h2",{id:"using-smaller-states-for-independant-features"},"Using smaller states for independant features"),Object(r.b)("p",null,"We typically have one large state that holds all the main data models for the application, but then we also have many smaller stores for independant features. For example, in Visly we have the ability to pan around and zoom in on the main editor canvas - we store this state in a ",Object(r.b)("inlineCode",{parentName:"p"},"zoomStore"),", as it is independant from data in the rest of the app."),Object(r.b)("h2",{id:"seperating-shared-code"},"Seperating shared code"),Object(r.b)("p",null,"We recommend creating a module with no React / browser dependencies that holds the state, selectors, and mutations which operate on data that is shared between both React and Node environments. This way, code is easily shared between client and server. If you wish to add any React-specific functionaility such as custom hooks that wrap state operations, you would place these outside of the main shared module. This makes state easy to reuse and test. "))}d.isMDXComponent=!0},72:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),d=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=d(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,h=p["".concat(i,".").concat(u)]||p[u]||m[u]||r;return n?o.a.createElement(h,s(s({ref:t},l),{},{components:n})):o.a.createElement(h,s({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);